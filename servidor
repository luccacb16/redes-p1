#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re

# Remover warnings de Decprecation do run_loop_forever()
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning) 

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


def getComando2(string):
    if string.startswith(b'PING'):
        return b'PING'
    
    if string.startswith(b'NICK'):
        return b'NICK'
    
    if string.startswith(b'PRIVMSG'):
        return b'PRIVMSG'
    
def getComando(string, comando):
    return string.startswith(comando)

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    # Separa os comandos (b'\r\n') sem apagar os b'\r\n'
    pattern = b'(?<=\r\n)'
    dados = [substring for substring in re.split(pattern, dados)]
    
    
    # Itera sob cada comando
    for d in dados:
        # Processa os comandos bem formados
        if d.endswith(b'\r\n'):
            
            # Concatena os residuais com os dados
            d = conexao.residuais + d
            
            # Comando PING
            if getComando(d, b'PING'):
                d = d.replace(b'PING ', b'')
                conexao.enviar(b':server PONG server :' + d)

            # Comando NICK
            if getComando(d, b'NICK'):
                nick = d.replace(b'NICK ', b'').replace(b'\r\n', b'')
                
                # Caso 1: Nome válido
                if validar_nome(nick):
                    
                    # Caso 1.1: Nick NÃO-disponível (não Case Sensitive)
                    if nick.lower() in apelidos:
                        
                        # Caso 1.1.1: 1o acesso
                        if conexao.nick == b'':
                            conexao.enviar(b':server 433 * %s :Nickname is already in use\r\n' % nick)
                            
                        # Caso 1.1.2: Troca
                        else:
                            conexao.enviar(b':server 433 %s %s :Nickname is already in use\r\n' % (conexao.nick, nick))
                    
                    # Caso 1.2: Nick disponível    
                    else:
                        # Caso 1.2.1: 1o acesso
                        if conexao.nick == b'':
                            conexao.enviar(b':server 001 %s :Welcome\r\n' % nick)
                            conexao.enviar(b':server 422 %s :MOTD File is missing\r\n' % nick)
                            
                        # Caso 1.2.2: Troca
                        else:
                            conexao.enviar(b':%s NICK %s\r\n' % (conexao.nick, nick))
                            del apelidos[conexao.nick.lower()] # Apaga o nome antigo do dicionário
                            
                        # Registra independente do caso
                        apelidos[nick.lower()] = conexao # Associa o nome e a conexão
                        conexao.nick = nick # Registra o nome da conexão no objeto

                # Caso 2: Nome inválido
                else:
                    conexao.enviar(b':server 432 * %s :Erroneous nickname\r\n' % nick)
                    
            # Comando PRIVMSG
            if getComando(d, b'PRIVMSG'):
                d = d.replace(b'PRIVMSG ', b'').replace(b'\r\n', b'')
                dest, msg = d.split(b' :', 1)
                
                if dest.lower() in apelidos:
                    apelidos[dest.lower()].enviar(b':%s PRIVMSG %s :%s\r\n' % (conexao.nick, dest, msg))

            # Printa
            print(conexao, d)
            
            # Reseta o resíduo
            conexao.residuais = b''
            
        else:
            # Concatena os dados que não terminam com b'\n' e salva nos residuais
            conexao.residuais += d

    # Caso os resíduos se completem e não hajam mais mensagens em seguida
    if conexao.residuais.endswith(b'\r\n'):
        conexao.enviar(b':server PONG server :' + conexao.residuais.replace(b'PING ', b'')) # Remove o comando PING
        conexao.residuais = b''
        
        print(conexao, d)



def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)
    
    # Passo 2
    conexao.residuais = b''
    
    # Passo 4
    conexao.nick = b''
    

# Lista de nomes
apelidos = {}

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
print('Servidor iniciado na porta 6667')
asyncio.get_event_loop().run_forever()